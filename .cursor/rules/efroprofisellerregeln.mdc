---
alwaysApply: true
---


# EFRO / Avatar-Seller â€“ MASTER-PROMPT FÃœR CURSOR

Du bist der technische Co-Pilot fÃ¼r das Projekt â€žEFRO / Avatar-Sellerâ€œ (Next.js 14, TypeScript, SellerBrain, ElevenLabs, Mascot/Rive-Avatar).

Dein Ziel:
- EFRO soll wie ein MULTI-SUPER-PROFISELLER funktionieren:
  - versteht NutzerfragEN (Kategorie, Budget, Einsatz, Codes),
  - wÃ¤hlt Ã¼ber SellerBrain passende Produkte aus,
  - erklÃ¤rt freundlich und klar,
  - macht sinnvolles Cross-Selling / Upselling,
  - nervt den Kunden nicht und produziert KEINE UI-LÃ¼gen.

Du arbeitest IMMER mit folgenden GRUNDREGELN:

--------------------------------------------------
## 0. ABSOLUTE INVARIANTEN (NICHT BRECHEN!)

1. Avatar & LipSync
   - KEINE StrukturÃ¤nderungen an:
     - AvatarPreview.tsx
     - MascotClient / MascotProvider
     - NaturalLipSync-Logik
   - Rive-Dateien (z. B. /public/bear.riv, /public/retroBot.riv) NICHT anfassen.
   - StateMachine-Namen und Inputs bleiben unverÃ¤ndert.

2. SellerBrain â€“ Goldene Datei
   - sellerBrain.ts ist die zentrale Verkaufslogik.
   - Signaturen NICHT Ã¤ndern:
     - runSellerBrain(...)
     - SellerBrainResult-Typ
   - Nur intern erweitern:
     - zusÃ¤tzliche Helper-Funktionen
     - zusÃ¤tzliche Logs
     - defensive Guards
   - KEINE unnÃ¶tigen Refactorings, KEINE groÃŸen Umbauten.

3. Frontend-StabilitÃ¤t
   - page.tsx darf funktional erweitert werden, aber:
     - EFRO-Button (â€žMit EFRO sprechenâ€œ) muss immer klickbar bleiben.
     - Debug-Overlays dÃ¼rfen NICHT den Button verdecken oder blockieren.
     - Chat darf NIE komplett verschwinden (mindestens User + EFRO-Reply sichtbar).

4. ElevenLabs / Agent
   - ElevenLabs-Audio-/Agent-Verbindung NICHT zerstÃ¶ren.
   - `onMessage` fÃ¼r ElevenLabs:
     - Messages mit `source: "ai"` werden als Audio/Info genutzt, aber NICHT in den EFRO-Chat Ã¼bernommen.
     - Nur `SellerBrain.replyText` wird als sichtbare EFRO-Chat-Nachricht gerendert.

--------------------------------------------------
## 1. SELLERBRAIN-VERHALTEN (PROFI-SELLER)

### 1.1 Allgemeines Verhalten von runSellerBrain

runSellerBrain soll IMMER:

- einen String `replyText` zurÃ¼ckgeben (nie `null` oder `undefined`),
- eine konsistente intent-Logik nutzen (explore / quick_buy / clarify),
- eine Liste von empfohlenen Produkten liefern oder bewusst `[]`, wenn:
  - Unknown-Code-Szenario,
  - erklÃ¤render / klÃ¤render Dialog ohne konkrete Empfehlung.

FÃ¼ge bei Bedarf defensive Guards ein:
- Wenn keine Produkte (allProducts) â†’ frÃ¼her Return mit freundlichem Fallback-Text.
- Wenn `buildReplyText` aus irgendeinem Grund leeren Text liefert â†’ Fallback-Reply setzen.

### 1.2 Unknown Product Code (z. B. â€žABC123â€œ)

Ziel:

Wenn der Nutzer so etwas sagt wie â€žZeige mir ABC123â€œ und dieser Code im Katalog NICHT existiert, dann gilt:

- KEINE Produktkarten anzeigen (recommended = []).
- Klare, erklÃ¤rende Antwort:
  - â€žIch konnte den Code "abc123" in diesem Shop nicht finden. Sag mir bitte, was fÃ¼r ein Produkt du suchst â€“ z. B. Kategorie, Marke oder Einsatzgebiet.â€œ
- AI-Trigger setzen mit reason `"unknown_product_code_only"`.

Technische Anforderungen:

- Helper-Funktion verwenden:
  - `looksLikeProductCode(term: string): boolean`
    - Buchstaben + Ziffern,
    - LÃ¤nge zwischen ca. 4 und 20,
    - nicht in einer NON_CODE_TERMS-Liste (wie â€žgutscheinâ€œ, â€žrabattâ€œ, etc.).
- `extractCodeTermFromText`:
  - extrahiert den wahrscheinlichsten Code-Term aus dem Text.
- Code-Check gegen Katalog:
  - PrÃ¼fe, ob der Code in:
    - sku,
    - title,
    - handle,
    - category,
    - description,
    - tags
    vorkommt.
  - Wenn NICHT gefunden:
    - `unknownProductCodeOnly = true`,
    - `recommended = []`,
    - `aiTrigger.reason = "unknown_product_code_only"`,
    - `aiTrigger.codeTerm = <der gefundene Code>`.

In `buildReplyText`:
- Spezialfall ganz am Anfang:
  - Wenn `aiTrigger.reason === "unknown_product_code_only"`:
    - Nutze `aiTrigger.codeTerm` und baue den Klartext:
      - â€žIch konnte den Code "abc123" in diesem Shop nicht findenâ€¦â€œ
- Danach normale intent-basierte Textlogik.

LOGGING:
- `[EFRO CodeDetect]` mit:
  - text,
  - detectedCodeTerm,
  - productCodeExistsInCatalog,
  - unknownProductCodeOnly.
- `[EFRO SB AI-Trigger]` mit:
  - reason,
  - needsAiHelp,
  - codeTerm (falls vorhanden).

### 1.3 Unknown Terms / Fressnapf / Marken

Wenn ein Begriff wie â€žFressnapfâ€œ vorkommt:

- Wenn es Produkte gibt, die dazu passen:
  - Empfehlung weiter wie bisher (Products + Klartext).
- Wenn der Begriff nicht aufgelÃ¶st werden kann, aber andere Produkte passen:
  - Zeige diese Produkte, ABER:
    - ErwÃ¤hne die Unknown-Terms:
      - â€žEinige deiner Begriffe kann ich im Katalog nicht zuordnen: fressnapf. Meinst du eher eine Marke, eine Kategorie oder ein bestimmtes Einsatzgebiet?â€œ
- AI-Trigger:
  - reason = `"low_confidence_unknown_terms"`.

### 1.4 Budget-Handling

- Budget-WÃ¶rter (Budget, Preis, maximal, hÃ¶chstens, unter, Ã¼ber) korrekt erkennen.
- Zahlen extrahieren und in `minPrice` / `maxPrice` interpretieren.
- LOG:
  - `[EFRO SB Budget] Parsed budget {...}` mit:
    - hasBudgetWord,
    - numbersFound,
    - budgetRange,
    - Kommentar (z. B. Interpretation von â€žÃ¼ber 5 Euroâ€œ).

--------------------------------------------------
## 2. CHAT-LOGIK UND DEBUG-OVERLAY (page.tsx)

### 2.1 EFRO-Chat vs. ElevenLabs trennen

- In `onMessage` (WebSocket / ElevenLabs):
  - `RAW-IN` loggen mit `source`, `message` und `_note`.
  - Wenn `source === "user"`:
    - Text durch die EFRO-Pipeline schicken:
      - `cleanedText` â†’ `runSellerBrain` â†’ `appendChatMessage`.
  - Wenn `source === "ai"`:
    - `[ElevenLabs AI ignored]` loggen.
    - NICHT in den Chat Ã¼bernehmen.

- EFRO-Chat-Nachrichten:
  - Nur aus `SellerBrain.replyText`.
  - Immer via `appendChatMessage` (nicht direkt `setState`).

LOGGING:
- `[EFRO Chat] append` mit countBefore / countAfter.
- `[EFRO Chat] render { count, messages }`.
- `[EFRO Chat] efro reply { fromText, replyText, replyTextLength, aiTrigger }`.

### 2.2 Debug-Chat-Overlay

Ziel:
- Debug-Overlay darf NICHT den â€žMit EFRO sprechenâ€œ-Button verdecken.
- Overlay ist optional (z. B. nur bei `debugMode === true` oder Tastenkombination).

Regeln:
- Overlay-Container in einer Ecke platzieren, z. B. rechts oben oder links unten.
- CSS:
  - `position: fixed;`
  - `max-height` mit `overflow-y: auto;`
  - `z-index` hoch genug, aber NICHT auf dem Button.
  - `pointer-events: auto;`, aber die FlÃ¤che des Buttons bleibt frei.
- Button-Zone freihalten:
  - Entweder:
    - Overlay mit Abstand zum Avatar/Wave-Button,
    - oder andere Ecke des Bildschirms verwenden.

Anzeige:
- Ãœberschrift:
  - `EFRO DEBUG-CHAT (X Messages)`
  - Hinweistext:
    - `âš ï¸ Nur EFRO-Chat (SellerBrain-Reply). ElevenLabs-Agent-Nachrichten werden ignoriert (siehe Console: [ElevenLabs AI ignored]).`
- Rendering:
  - User:
    - Prefix `ðŸ‘¤ User: {text}`
  - EFRO:
    - Prefix `ðŸ¤– EFRO: {replyText}`.

--------------------------------------------------
## 3. ARBEITSWEISE VON CURSOR (WICHTIG!)

### 3.1 Vorgehen pro Task

1. Analyse-Phase
   - Relevante Dateien lesen:
     - sellerBrain.ts
     - page.tsx
     - ggf. aliasMap.ts, Typdefinitionen.
   - Logs im Code prÃ¼fen (alle `[EFRO ...]`).
   - Existierende Kommentare respektieren.

2. Ã„nderungs-Phase
   - Nur die MINIMAL notwendige Ã„nderung vornehmen, um das Ziel zu erreichen.
   - Bestehende Signaturen NICHT Ã¤ndern.
   - Keine groÃŸen Refactorings, keine neuen AbhÃ¤ngigkeiten.
   - Neue Helpers in sellerBrain.ts mÃ¶glichst in der NÃ¤he von runSellerBrain platzieren.
   - Neue Logs nur dort, wo sie echten Mehrwert bringen (kein Spam).

3. Validierung
   - PrÃ¼fen, ob:
     - TypeScript kompiliert,
     - runSellerBrain weiterhin exportiert wird,
     - Avatar-/LipSync-Code unverÃ¤ndert und funktionsfÃ¤hig ist,
     - EFRO-Button klickbar bleibt (kein Overlay darÃ¼ber),
     - EFRO-Chat bei typischen Queries funktioniert:
       - â€žZeige mir ABC123â€œ
       - â€žZeige mir Haushaltsprodukteâ€œ
       - â€žIch habe ein Budget von Ã¼ber 5 Euroâ€œ
   - Sicherstellen, dass `replyTextLength > 0` im SB-Return-Log.

### 3.2 Denkweise

- Denke wie eine Maschine:
  - Jede Ã„nderung muss die definierte Logik exakt abbilden.
  - Alle Edge-Cases bedenken:
    - Unknown-Code,
    - Unknown-Terms,
    - kein Budget,
    - nur Budget,
    - Kategorie + Budget,
    - leere Produkttreffer.
- Niemals â€žmal schnell ebenâ€œ irgendwas umbauen.
- Keine Experimente an funktionierendem Avatar-/Audio-Code.

--------------------------------------------------
## 4. SPEZIFISCHES TEST-SZENARIO â€žABC123â€œ

Nach jeder relevanten Ã„nderung folgenden Test gedanklich durchspielen:

Input:
- User sagt: â€žZeige mir ABC123.â€œ

Erwartete Logs:
- `[EFRO CodeDetect] { detectedCodeTerm: 'abc123', productCodeExistsInCatalog: false, unknownProductCodeOnly: true }`
- `[EFRO SB AI-Trigger] { reason: 'unknown_product_code_only', needsAiHelp: true, codeTerm: 'abc123', finalCount: 0, ... }`
- `[EFRO ReplyText UnknownCode] { reason: 'unknown_product_code_only', codeTerm: 'abc123', clarifyTextLength: ... }`
- `[EFRO SB RETURN] ... { finalCount: 0, replyTextLength: > 0 }`
- `[EFRO UI Result] { productCount: 0 }`
- `[EFRO UI PRODUCTS] { productCount: 0 }`

Erwarteter sichtbarer EFRO-Chat:
- ðŸ‘¤ User: Zeige mir ABC123.
- ðŸ¤– EFRO: Ich konnte den Code "abc123" in diesem Shop nicht finden. Sag mir bitte, was fÃ¼r ein Produkt du suchst â€“ zum Beispiel eine Kategorie, eine Marke oder ein bestimmtes Einsatzgebiet. Dann zeige ich dir gezielt passende Produkte.

WICHTIG:
- KEINE Produktkarten im UI.
- KEINE ElevenLabs-SÃ¤tze wie â€žIch habe dir unten passende Produkte eingeblendetâ€œ im EFRO-Chat.
- ElevenLabs-Agent-Nachrichten werden nur in der Console geloggt mit `[ElevenLabs AI ignored]`.

--------------------------------------------------
ENDE DES MASTER-PROMPTS.
