export const runtime = "nodejs";
export const dynamic = "force-dynamic";
export const revalidate = 0;
export const fetchCache = "force-no-store";

// src/app/api/efro/products/route.ts
import { NextRequest, NextResponse } from "next/server";
import {
  loadProductsForShop,
  type LoadProductsResult,
} from "@/lib/products/efroProductLoader";
import {
  getEfroShopByDomain,
  getEfroDemoShop,
  getProductsForShop,
} from "@/lib/efro/efroSupabaseRepository";
import type { EfroProduct } from "@/lib/products/mockCatalog";
import { mockCatalog } from "@/lib/products/mockCatalog";

/**
 * Mojibake Repair (UTF-8 bytes fälschlich als Latin1 interpretiert)
 * Beispiele:
 * - "ParfÃ¼m" -> "Parfüm"
 * - "Ã¢âÂ¬" -> "€" (Mehrfach-Durchläufe nötig)
 */
function looksLikeMojibake(s: string): boolean {
  return /Ã|Â|â€|â€™|â€œ|â€�|â€“|â€¦|â‚¬|â¬/.test(s);
}

function repairMojibakeUtf8(input: unknown): string {
  const original = typeof input === "string" ? input : "";
  if (!original) return original;

  let out = original;

  try {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const B: any = (globalThis as any).Buffer;
    if (typeof B !== "undefined") {
      // bis zu 3 Durchläufe: manche Strings sind doppelt kaputt (z.B. Ã¢âÂ¬)
      for (let i = 0; i < 3; i++) {
        if (!looksLikeMojibake(out)) break;
        const prev = out;
        out = B.from(out, "latin1").toString("utf8");
        if (out === prev) break;
      }
    }
  } catch {
    // ignore
  }

  // letzte Kante: Euro taucht manchmal als â‚¬ oder â¬ auf
  out = out.replace(/â‚¬/g, "€").replace(/â¬/g, "€");

  return out;
}

function repairProducts<T>(products: T[]): T[] {
  return (products || ([] as T[])).map((p) => {
    if (!p || typeof p !== "object") return p;

    const out: any = { ...(p as any) };

    const fixField = (k: string) => {
      if (k in out) out[k] = repairMojibakeUtf8(out[k]);
    };

    // typische Felder in EFRO / Shopify / Repository
    fixField("title");
    fixField("description");
    fixField("handle");
    fixField("vendor");
    fixField("category");
    fixField("product_type");

    if ("tags" in out) {
      if (Array.isArray(out.tags)) out.tags = out.tags.map((t: any) => repairMojibakeUtf8(t));
      else out.tags = repairMojibakeUtf8(out.tags);
    }

    return out as T;
  });
}

type ShopifyProduct = {
  id: string | number;
  title: string;
  body_html?: string;
  product_type?: string;
  tags?: string;
  variants?: { price?: string | null }[];
  image?: { src?: string | null } | null;
  images?: { src?: string | null }[];
};

function stripHtml(html: string): string {
  return html.replace(/<[^>]*>/g, "").trim();
}

function mapShopifyToEfro(sp: ShopifyProduct): EfroProduct {
  const priceRaw =
    sp.variants && sp.variants.length > 0 && sp.variants[0]?.price
      ? sp.variants[0].price!
      : "0";
  const price = Number.parseFloat(priceRaw) || 0;

  const tags: string[] =
    sp.tags
      ?.split(",")
      .map((t) => t.trim())
      .filter(Boolean) ?? [];

  const category =
    sp.product_type && sp.product_type.trim().length > 0
      ? sp.product_type
      : "shopify";

  const description =
    sp.body_html && sp.body_html.trim().length > 0
      ? stripHtml(sp.body_html)
      : sp.title;

  const imageUrl = (sp.image && sp.image.src) || (sp.images && sp.images[0]?.src) || "";

  return {
    id: String(sp.id),
    title: sp.title,
    description,
    price,
    imageUrl,
    tags,
    category,
  };
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const shopDomain = searchParams.get("shop");

    // Für shop=demo: gleiche Logik wie debug-products (Szenario-Tests)
    if (shopDomain?.trim().toLowerCase() === "demo") {
      const url = new URL(request.url);
      const baseUrl = `${url.protocol}//${url.host}`;

      try {
        const res = await fetch(`${baseUrl}/api/shopify-products`, {
          cache: "no-store",
        });

        if (!res.ok) {
          return NextResponse.json({
            success: true,
            source: "mock",
            products: repairProducts(mockCatalog),
            shopDomain: "demo",
          });
        }

        const data = await res.json();
        const rawProducts: ShopifyProduct[] = Array.isArray(data.products) ? data.products : [];

        if (rawProducts.length === 0) {
          return NextResponse.json({
            success: true,
            source: "mock",
            products: repairProducts(mockCatalog),
            shopDomain: "demo",
          });
        }

        const products: EfroProduct[] = rawProducts.map(mapShopifyToEfro);

        return NextResponse.json({
          success: true,
          source: "shopify",
          products: repairProducts(products),
          shopDomain: "demo",
        });
      } catch (err: any) {
        return NextResponse.json({
          success: true,
          source: "mock",
          products: repairProducts(mockCatalog),
          shopDomain: "demo",
        });
      }
    }

    // Repository (Supabase)
    let shop = await getEfroShopByDomain(shopDomain || "");
    if (!shop) {
      shop = await getEfroDemoShop();
    }

    if (shop) {
      const repoResult = await getProductsForShop(shop);

      if (repoResult.products.length > 0) {
        return NextResponse.json({
          success: true,
          source: repoResult.source,
          products: repairProducts(repoResult.products),
          shopDomain: shopDomain || null,
        });
      }
    }

    // Fallback: loadProductsForShop (Shopify/Mock)
    const result: LoadProductsResult = await loadProductsForShop(shopDomain || null);

    return NextResponse.json({
      ...result,
      products: repairProducts(result.products || []),
    });
  } catch (err: any) {
    console.error("[EFRO Products API] Unexpected error", err);
    return NextResponse.json(
      {
        success: false,
        source: "none" as const,
        products: [],
        error: err?.message || String(err),
      },
      { status: 500 }
    );
  }
}
